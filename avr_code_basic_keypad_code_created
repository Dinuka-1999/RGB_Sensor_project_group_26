/*
 * project_26_05_2021.cpp
 *
 * Created: 5/26/2021 4:36:27 PM
 * Author : vakeesan
 */ 
/*==================== pin connection ========================
					    -----------------
		key_col_1	|PD0			  PB0	|	R	
		key_col_2	|PD1			  PB1	|	EN
		key_col_3	|PD2		  	PB2	|	D4_LCD
		key_row_1	|PD3		  	PB3	|	D5_LCD
		key_row_2	|PD4		  	PB4	|	D6_LCD
		key_row_3	|PD5		  	PB5	|	D7_LCD
		key_row_4	|PD6		  	PB6	|	XTAL_1
	red_sen_led	|PD7		  	PB7	|	XTAL_2
					    |				   PC0	|	LDR
					    |			    	PC1	|	red_out_led
					    |			    	PC2	|	green_out_led
					    |			    	PC3	|	blue_out_led
					    |			     	PC4	|	green_sen_led
					    |			     	PC5	|	blue_sen_led
					    |			     	PC6	|
					    -----------------

*/

#include <avr/io.h>
#define F_CPU 16000000UL
#include <avr/interrupt.h>
#include <util/delay.h>

#define times 5
#define led_out_prt PORTC
#define lcd_prt PORTB
#define red_sen 7
#define green_sen 4
#define blue_sen 5
#define red_out 1
#define green_out 2
#define blue_out 3
#define ldr 0
#define RS 0 //RS pin of lcd
#define EN 1 //enable pin of lcd
unsigned char iscalibrated =0;
unsigned int caliArr[2][3];
unsigned int adc_val;
unsigned char keypad[4][3]={{'0','1','2'},
							{'3','4','5'},
							{'6','7','8'},
							{'9','*','#'}};
// all the functions
void calibration(void);
void sensing(void);
void output (void);
void ADC_read(void);
void LCD_init();
void LCD_command(unsigned char cmd);
void LCD_data(unsigned char data);
void LCD_goto(unsigned char x, unsigned char y);
void LCD_print(char *str);
unsigned char key_scan();




// calibration function

void calibration(void)
{
	iscalibrated=1;
	unsigned int red_val,green_val,blue_val;
	unsigned char i;
	unsigned int total;
	//lcd code for showing white surface
	
	LCD_print("show white to sensor!");
	//turn on red led
	PORTD |=(1<<red_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	
	_delay_us(100);
	//turn off the red led
	PORTD &=~(1<<red_sen);
	//find the average
	red_val=round(total/times);
	total=0;
	
	//turn on green led
	PORTC |=(1<<green_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the green led
	PORTC &= ~(1<<green_sen);
	//find the average
	green_val=round(total/times);
	total=0;
	//turn on blue led
	PORTC |= (1<<blue_sen);
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the blue led
	PORTC &=~(1<<blue_sen);
	//find the average
	blue_val=round(total/times);
	caliArr[0][0]=red_val;
	caliArr[0][1]=green_val;
	caliArr[0][2]=blue_val;
	
	//lcd code for showing black surface
	//turn on red led
	PORTD |=(1<<red_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	
	_delay_us(100);
	//turn off the red led
	PORTD &=~(1<<red_sen);
	//find the average
	red_val=round(total/times);
	total=0;
	//turn on green led
	PORTC |=(1<<green_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the green led
	PORTC &= ~(1<<green_sen);
	//find the average
	green_val=round(total/times);
	total=0;
	//turn on blue led
	PORTC |= (1<<blue_sen);
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the blue led
	PORTC &=~(1<<blue_sen);
	//find the average
	blue_val=round(total/times);
	caliArr[1][0]=red_val;
	caliArr[1][1]=green_val;
	caliArr[1][2]=blue_val;
	
}
// sensing function
void sensing()
{
	unsigned int red_val,green_val,blue_val;
	unsigned char i;
	unsigned int total;
	
	//turn on red led 
	PORTD |=(1<<red_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	
	_delay_us(100);
	//turn off the red led
	PORTD &=~(1<<red_sen);
	//find the average
	red_val=round(total/times);
	total=0;
	//turn on green led
	PORTC |=(1<<green_sen);
	
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the green led
	PORTC &= ~(1<<green_sen);
	//find the average
	green_val=round(total/times);
	total=0;
	//turn on blue led
	PORTC |= (1<<blue_sen);
	for ( i=0; i<times; i++)
	{
		//get the value from adc
		ADC_read();
		//get the total
		total+=adc_val;
	}
	_delay_us(100);
	//turn off the blue led
	PORTC &=~(1<<blue_sen);
	//find the average
	blue_val=round(total/times);
	
	//output the led according to the voltage give by values

}

//output the colour by manual
// it will only accept the numerical value then translate to dac 
// not accept non numerical so u have to change the type before calling it
void output (void)
{
	//turn on all the leds with correct values of array
	//get the keypad value for each colour then out put the leds
	_delay_us(500);
}
// adc interrupt function
ISR(ADC_vect)
{
	unsigned char lowBit=ADCL; // assign the low bits(first 8 bits) to the lowbit 
	unsigned char highBit=ADCH; // assign the high bits(last 2 bits) to the high bit
	adc_val=(highBit<<8)|lowBit; // find the full 10 bit value
	ADCSRA =(1<<ADSC); // strat the adc conversion

}
void ADC_read(void)
{
	sei(); //enable the interrupt
	ADCSRA=0x8F; //enable the interrupt and clock speed/128 timer
	ADMUX = 0xC0; //2.56 v for ref and ADC0 for single ended input and right adjust input
	ADCSRA|=(1<<ADSC); //start the conversion
	
}

void LCD_init()
{
	PORTB &= ~(1<<EN);
	_delay_us(2000);  //wait for stable power
	LCD_command(0x33);  // 4 bit mode
	_delay_us(100);
	LCD_command(0x32);  // 4 bit mode
	_delay_us(100);
	LCD_command(0x28);  //4 bit mode
	_delay_us(100);
	LCD_command(0x0E);  // display on cursor on
	_delay_us(100);
	LCD_command(0x01);  // clear lcd
	_delay_us(100);
	LCD_command(0x06);   //shift cursor right
	_delay_us(100);
	
}
void LCD_command(unsigned char cmd)
{
	PORTB &= ~(1<<RS); //RS =0 for command
	PORTB |=(1<<EN);   // EN =1 for enable
	_delay_us(1);      //wait to make EN wider
	PORTB &= ~(1<<EN); // EN =0 
	_delay_us(20);
	PORTB = (PORTB & 0xC3)|(cmd<<2);
	PORTB |=(1<<EN);   // EN =1
	_delay_us(1);
	PORTB &= ~(1<<EN);  //EN =0
}
void LCD_data(unsigned char data)
{
	PORTB |= (1<<RS);  // RS=1 for data
	PORTB |= (1<<EN);  // EN=1
	_delay_us(1);
	PORTB &=~(1<<EN);   //EN=0
	PORTB =(PORTB & 0xC3)|(data<<2);  
	PORTB |= (1<<EN);  // EN =1
	_delay_us(1);
	PORTB &= ~ (1<<EN);  // EN=0
	
}
void LCD_goto(unsigned char x, unsigned char y)
{
	unsigned char firstChar[]={0x80,0xc0};
	LCD_command(firstChar[y-1]+x-1);
	_delay_us(100);
}
void LCD_print(char *str)
{
	unsigned char i =0;
	while(str[i]!=0)
	{
		LCD_data(str[i]);
		i++;
	}
}
unsigned char key_scan()
{
	unsigned char col, row;
	while(1)
	{	do 
		{
	
			PORTD &=0x07; // set rows are 1s and columns are 0s
			col = (PIND & 0x07);  // read the columns
		}	while(col != 0x07); // check until all keys released
		
		do 
		{
			do 
			{
				_delay_ms(20);  //call delay
				col = (PIND & 0x07);   //see if any key is pressed
			}	while (col==0x07); //keep checking for key pressed
			
			_delay_ms(20);  // call delay for debounce
			col = (PIND & 0x07);  //read columns
		} while (col==0x07);  // wait for keypress
		while(1)
		{
			PORTD = 0x77;   // ground only 1 st row
			col = (PIND & 0x07);  // read the columns
			if(col != 0x07)  //column detected
			{
				row=0;  //save the row location
				break;  //exit while loop
			}
			PORTD = 0x6F;  //ground the 2nd row
			col = (PIND & 0x07);  // read the coulumn
			
			if (col !=0x07)  //column detected
			{
				row=1;  //save the row
				break;  //exit while loop
			}
			PORTD = 0x5F;  //ground the 3rd row
			col = (PIND & 0x07);  // read the coulumn
			
			if (col !=0x07)  //column detected
			{
				row=2;  // save the row
				break;  //exit the while loop
			}
			PORTD = 0x3F;  //ground the 4th row
			col = (PIND & 0x07);  // read the coulumn
			
			row = 3;  // save the row
			break;  //exit the while loop
			}
			//check the column and send the result
			if (col==0x06) col=0;
			else if (col==0x05) col=1;
			else col=2;
			
		}
		return (keypad[row][col]);
		
		
	}
	
	
	
	
	

int main(void)
{
    //define the initial functions
	DDRD=0b11111000;   //keypad pins that columns are input and rows are output and red led on the sensor is output 
	DDRB=0b11111111;   //lcd and leds for sensor are defined as output
	DDRC=0b11111110;   // ldr is input and other pins are output
    LCD_init();   // initialize the lcd display
	LCD_command(0x01);  //clear the screen
	LCD_goto(1,1);
	LCD_print("Welcome");
	while (1) 
    {
		// input from keypad
		unsigned char key = key_scan();
		
		if (key=='1')
		{
			calibration();
		}
		
		else if (key=='2')
		{
			if (iscalibrated==0) calibration();
			sensing();
			//correct algorithm for chnaging adc value to numrical value

		}
		
		else if (key=='3')
		{
			//just call the output
			output();
		}
		else if (key=='*')
		{
			break;
		}
    }
}
